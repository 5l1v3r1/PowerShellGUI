#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: 6ca0c3d3-c223-4047-bf67-578fa0ae79a1
# Source File: MultiThreading_Arguments.psf
#------------------------------------------------------------------------
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
lw0AAB+LCAAAAAAABADNV11v2jAUfZ+0/2D5OQJCCBQpRGrZum4rWzWybm/ISS7Uq2NXtgPNfv2c
j7Z8taQVoAkJxeZen3N8T3yN9wMiMQeZfSCaIPOgqOAD3Mb++3cIed8lnVFO2Dll8I0k4I9Spmlw
I4HElM8mp3KWJsC1atypqdfcCC8XCf9ApJHO7mCAx5nSkDR+UR6LhWqcC5mU3xba9pOFritOnUYr
/1hoaCikEgYcUi0Js9BVGjIafYUsELfAB2GvR9zI7dp9pwOtkz5G3FAZ4KlZz8YouqEsliYODwXX
UjBVajVEr6S4A6mzKmHIqJE2pn8B+91e30Idt+81H4KeScplY7/A2hkbwL3Gfq5zM/Tj3GBXcXnE
kAkFcbnyiFA+eZr0mkXwtsxLQaoce5I/r4XursxZqrXgB69NWMCMQc5pBOqlIm3u4qWIiDYssN/v
WMg5aW9s5nNVWkWtkVZ6oedaqO3UCA9I+JnHcI/9OpxKN7yCzU8F11SlhI11xuCMRLdDwYTEfiBT
2Ja/7Axj7uh2fQsmxeyaSZqlS/5TzxiVhvibLWM7b7FMBXpIx2yeHs85pj6Z/RmmwtyPX/LW80nS
+JrC4uCuiQ3YzIDNDdiL3WBLPxAsTfiFaX2GzAXQ2U3RHEYiNiU+TbXIRzXKsOS+toXs+uZb4V7b
fF3XuM/pvs5+rc2OtFzX1cHuEgc0AXnw2uoc5YsIA2msDRJv64hB4eK1yEmwZuNVfadKQWIYgHpY
sZrJ/ErRiHAyg/wm1MiNkBT1fVLm1FXm2OHUOXG7JHa6HXBcr/mItI6cqEhIRsM97N8LKKW+Y2Ds
3RW7EfOD5zhAkizMdfktWC1n6k57U9uO3RZxyG6s3wk7jiYqzQsiZPZweTiKuqGQcBR5laqq0e1f
2+OwPFW85vIfMf8fwA6DepcNAAA=#>
#endregion

<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2014 v4.1.75
     Generated on:       2015-01-26 1:11 PM
     Generated by:       Francois-xavier.cat
     Organization:       LazyWinAdmin.com
    --------------------------------------------------------------------------------
    .DESCRIPTION
        GUI script generated by PowerShell Studio 2014
#>
#----------------------------------------------
#region Application Functions
#----------------------------------------------

function OnApplicationLoad {
	#Note: This function is not called in Projects
	#Note: This function runs before the form is created
	#Note: To get the script directory in the Packager use: Split-Path $hostinvocation.MyCommand.path
	#Note: To get the console output in the Packager (Windows Mode) use: $ConsoleOutput (Type: System.Collections.ArrayList)
	#Important: Form controls cannot be accessed in this function
	#TODO: Add modules and custom code to validate the application load
	
	return $true #return true for success or false for failure
}

function OnApplicationExit {
	#Note: This function is not called in Projects
	#Note: This function runs after the form is closed
	#TODO: Add custom code to clean up and unload modules when the application exits
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}

#endregion Application Functions

#----------------------------------------------
# Generated Form Function
#----------------------------------------------
function Call-MultiThreading_Arguments_psf {

	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form1 = New-Object 'System.Windows.Forms.Form'
	$buttonServices = New-Object 'System.Windows.Forms.Button'
	$buttonProcess = New-Object 'System.Windows.Forms.Button'
	$datagridview1 = New-Object 'System.Windows.Forms.DataGridView'
	$timerJobTracker = New-Object 'System.Windows.Forms.Timer'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	# Define some argument to pass to the Add-JobTracker function
	[string]$ProcessName = "Chrome"
	[array]$Property = "Name","Handles"
	
	
	
	
	
	
	$form1_Load={
		#TODO: Initialize Form Controls here
		
	}
	
	$formMain_FormClosed=[System.Windows.Forms.FormClosedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.FormClosedEventArgs]
		#Stop any pending jobs
		Stop-JobTracker
	}
	
	$timerJobTracker_Tick={
		Update-JobTracker
	}
	
	#region Job Tracker
	$JobTrackerList = New-Object System.Collections.ArrayList
	function Add-JobTracker
	{
		<#
			.SYNOPSIS
				Add a new job to the JobTracker and starts the timer.
		
			.DESCRIPTION
				Add a new job to the JobTracker and starts the timer.
		
			.PARAMETER  Name
				The name to assign to the Job
		
			.PARAMETER  JobScript
				The script block that the Job will be performing. 
				Important: Do not access form controls from this script block.
		
			.PARAMETER ArgumentList
				The arguments to pass to the job
		
			.PARAMETER  CompleteScript
				The script block that will be called when the job is complete.
				The job is passed as an argument. The Job argument is null when the job fails.
		
			.PARAMETER  UpdateScript
				The script block that will be called each time the timer ticks. 
				The job is passed as an argument. Use this to get the Job's progress.
		
			.EXAMPLE
				Job-Begin -Name "JobName" `
				-JobScript {	
					Param($Argument1)#Pass any arguments using the ArgumentList parameter
					#Important: Do not access form controls from this script block.
					Get-WmiObject Win32_Process -Namespace "root\CIMV2"
				}`
				-CompletedScript {
					Param($Job)		
					$results = Receive-Job -Job $Job		
				}`
				-UpdateScript {
					Param($Job)
					#$results = Receive-Job -Job $Job -Keep
				}
		
			.LINK
				
		#>
		
		Param(
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[string]$Name, 
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[ScriptBlock]$JobScript,
		$ArgumentList = $null,
		[ScriptBlock]$CompletedScript,
		[ScriptBlock]$UpdateScript)
		
		#Start the Job
		$job = Start-Job -Name $Name -ScriptBlock $JobScript -ArgumentList $ArgumentList
		
		if($job -ne $null)
		{
			#Create a Custom Object to keep track of the Job & Script Blocks
			$members = @{	'Job' = $Job;
							'CompleteScript' = $CompletedScript;
							'UpdateScript' = $UpdateScript}
			
			$psObject = New-Object System.Management.Automation.PSObject -Property $members
			
			[void]$JobTrackerList.Add($psObject)	
			
			#Start the Timer
			if(-not $timerJobTracker.Enabled)
			{
				$timerJobTracker.Start()
			}
		}
		elseif($CompletedScript -ne $null)
		{
			#Failed
			Invoke-Command -ScriptBlock $CompletedScript -ArgumentList $null
		}
	
	}
	
	function Update-JobTracker
	{
		<#
			.SYNOPSIS
				Checks the status of each job on the list.
		#>
		
		#Poll the jobs for status updates
		$timerJobTracker.Stop() #Freeze the Timer
		
		for($index = 0; $index -lt $JobTrackerList.Count; $index++)
		{
			$psObject = $JobTrackerList[$index]
			
			if($psObject -ne $null) 
			{
				if($psObject.Job -ne $null)
				{
					if($psObject.Job.State -ne "Running")
					{				
						#Call the Complete Script Block
						if($psObject.CompleteScript -ne $null)
						{
							#$results = Receive-Job -Job $psObject.Job
							Invoke-Command -ScriptBlock $psObject.CompleteScript -ArgumentList $psObject.Job
						}
						
						$JobTrackerList.RemoveAt($index)
						Remove-Job -Job $psObject.Job
						$index-- #Step back so we don't skip a job
					}
					elseif($psObject.UpdateScript -ne $null)
					{
						#Call the Update Script Block
						Invoke-Command -ScriptBlock $psObject.UpdateScript -ArgumentList $psObject.Job
					}
				}
			}
			else
			{
				$JobTrackerList.RemoveAt($index)
				$index-- #Step back so we don't skip a job
			}
		}
		
		if($JobTrackerList.Count -gt 0)
		{
			$timerJobTracker.Start()#Resume the timer	
		}	
	}
	
	function Stop-JobTracker
	{
		<#
			.SYNOPSIS
				Stops and removes all Jobs from the list.
		#>
		#Stop the timer
		$timerJobTracker.Stop()
		
		#Remove all the jobs
		while($JobTrackerList.Count -gt 0)
		{
			$job = $JobTrackerList[0].Job
			$JobTrackerList.RemoveAt(0)
			Stop-Job $job
			Remove-Job $job
		}
	}
	#endregion
	
	#region Control Helper Functions
	function Load-DataGridView
	{
		<#
		.SYNOPSIS
			This functions helps you load items into a DataGridView.
	
		.DESCRIPTION
			Use this function to dynamically load items into the DataGridView control.
	
		.PARAMETER  DataGridView
			The ComboBox control you want to add items to.
	
		.PARAMETER  Item
			The object or objects you wish to load into the ComboBox's items collection.
		
		.PARAMETER  DataMember
			Sets the name of the list or table in the data source for which the DataGridView is displaying data.
	
		#>
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			[System.Windows.Forms.DataGridView]$DataGridView,
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			$Item,
		    [Parameter(Mandatory=$false)]
			[string]$DataMember
		)
		$DataGridView.SuspendLayout()
		$DataGridView.DataMember = $DataMember
		
		if ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
		{
			$DataGridView.DataSource = $Item
		}
		else
		{
			$array = New-Object System.Collections.ArrayList
			
			if ($Item -is [System.Collections.IList])
			{
				$array.AddRange($Item)
			}
			else
			{	
				$array.Add($Item)	
			}
			$DataGridView.DataSource = $array
		}
		
		$DataGridView.ResumeLayout()
	}
	#endregion
	
	$buttonProcess_Click={
		#TODO: Place custom script here
		Add-JobTracker `
		-Name "Processes" `
		-JobScript {
			PARAM ($Process, $Property)
			Get-Process $Process | Select-Object -Property $Property
	 		Start-Sleep -Seconds 5
		} `
		-CompletedScript {
			#PARAM($job)
			PARAM ($Property)
			$results = Receive-Job -Name "Processes"
			Load-DataGridView -DataGridView $datagridview1 -Item $results
			
		}`
		-ArgumentList $ProcessName,$Property
		
		#-ArgumentList "win32_process" `
	}
	
	$buttonServices_Click={
		#TODO: Place custom script here
		Add-JobTracker `
		-Name "Services" `
		-JobScript {
			Get-Service
		} `
		-CompletedScript {
			#PARAM($job)
			$results = Receive-Job -Name "Services"
			Load-DataGridView -DataGridView $datagridview1 -Item $results
		}
		#-ArgumentList "win32_process" `
	}
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form1.WindowState = $InitialFormWindowState
	}
	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$buttonServices.remove_Click($buttonServices_Click)
			$buttonProcess.remove_Click($buttonProcess_Click)
			$form1.remove_FormClosed($formMain_FormClosed)
			$form1.remove_Load($form1_Load)
			$timerJobTracker.remove_Tick($timerJobTracker_Tick)
			$form1.remove_Load($Form_StateCorrection_Load)
			$form1.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form1.SuspendLayout()
	#
	# form1
	#
	$form1.Controls.Add($buttonServices)
	$form1.Controls.Add($buttonProcess)
	$form1.Controls.Add($datagridview1)
	$form1.ClientSize = '679, 459'
	$form1.Name = "form1"
	$form1.Text = "Form"
	$form1.add_FormClosed($formMain_FormClosed)
	$form1.add_Load($form1_Load)
	#
	# buttonServices
	#
	$buttonServices.Location = '94, 382'
	$buttonServices.Name = "buttonServices"
	$buttonServices.Size = '75, 23'
	$buttonServices.TabIndex = 2
	$buttonServices.Text = "Services"
	$buttonServices.UseVisualStyleBackColor = $True
	$buttonServices.add_Click($buttonServices_Click)
	#
	# buttonProcess
	#
	$buttonProcess.Location = '13, 382'
	$buttonProcess.Name = "buttonProcess"
	$buttonProcess.Size = '75, 23'
	$buttonProcess.TabIndex = 1
	$buttonProcess.Text = "Process"
	$buttonProcess.UseVisualStyleBackColor = $True
	$buttonProcess.add_Click($buttonProcess_Click)
	#
	# datagridview1
	#
	$datagridview1.ColumnHeadersHeightSizeMode = 'AutoSize'
	$datagridview1.Location = '12, 12'
	$datagridview1.Name = "datagridview1"
	$datagridview1.Size = '655, 363'
	$datagridview1.TabIndex = 0
	#
	# timerJobTracker
	#
	$timerJobTracker.add_Tick($timerJobTracker_Tick)
	$form1.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form1.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form1.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form1.add_FormClosed($Form_Cleanup_FormClosed)
	#Show the Form
	return $form1.ShowDialog()

} #End Function

#Call OnApplicationLoad to initialize
if((OnApplicationLoad) -eq $true)
{
	#Call the form
	Call-MultiThreading_Arguments_psf | Out-Null
	#Perform cleanup
	OnApplicationExit
}
