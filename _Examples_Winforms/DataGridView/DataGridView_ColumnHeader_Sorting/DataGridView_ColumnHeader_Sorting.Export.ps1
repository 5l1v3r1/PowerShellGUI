#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: f426f1e9-20a8-4395-ab6f-034a4440c281
# Source File: DataGridView_ColumnHeader_Sorting.psf
#------------------------------------------------------------------------

<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2014 v4.1.75
     Generated on:       2015-01-10 7:08 PM
     Generated by:       Francois-Xavier Cat
     Organization:       LazyWinAdmin.com
    --------------------------------------------------------------------------------
    .DESCRIPTION
        GUI script generated by PowerShell Studio 2014
#>
#----------------------------------------------
#region Application Functions
#----------------------------------------------

function OnApplicationLoad {
	#Note: This function is not called in Projects
	#Note: This function runs before the form is created
	#Note: To get the script directory in the Packager use: Split-Path $hostinvocation.MyCommand.path
	#Note: To get the console output in the Packager (Windows Mode) use: $ConsoleOutput (Type: System.Collections.ArrayList)
	#Important: Form controls cannot be accessed in this function
	#TODO: Add modules and custom code to validate the application load
	
	return $true #return true for success or false for failure
}

function OnApplicationExit {
	#Note: This function is not called in Projects
	#Note: This function runs after the form is closed
	#TODO: Add custom code to clean up and unload modules when the application exits
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}

#endregion Application Functions

#----------------------------------------------
# Generated Form Function
#----------------------------------------------
function Call-DataGridView_ColumnHeader_Sorting_psf {

	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$form1 = New-Object 'System.Windows.Forms.Form'
	$datagridview1 = New-Object 'System.Windows.Forms.DataGridView'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	
	
	
	$form1_Load = {
		$Processes = Get-Process | Select-Object -Property Name, id, ws
		$ProcessesDT = ConvertTo-DataTable -InputObject $Processes
		Load-DataGridView -DataGridView $datagridview1 -Item $ProcessesDT
	}
	
	#region Control Helper Functions
	function Load-DataGridView
	{
		<#
		.SYNOPSIS
			This functions helps you load items into a DataGridView.
	
		.DESCRIPTION
			Use this function to dynamically load items into the DataGridView control.
	
		.PARAMETER  DataGridView
			The ComboBox control you want to add items to.
	
		.PARAMETER  Item
			The object or objects you wish to load into the ComboBox's items collection.
		
		.PARAMETER  DataMember
			Sets the name of the list or table in the data source for which the DataGridView is displaying data.
	
		#>
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			[System.Windows.Forms.DataGridView]$DataGridView,
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			$Item,
		    [Parameter(Mandatory=$false)]
			[string]$DataMember
		)
		$DataGridView.SuspendLayout()
		$DataGridView.DataMember = $DataMember
		
		if ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
		{
			$DataGridView.DataSource = $Item
		}
		else
		{
			$array = New-Object System.Collections.ArrayList
			
			if ($Item -is [System.Collections.IList])
			{
				$array.AddRange($Item)
			}
			else
			{	
				$array.Add($Item)	
			}
			$DataGridView.DataSource = $array
		}
		
		$DataGridView.ResumeLayout()
	}
	
	function ConvertTo-DataTable
	{
			<#
				.SYNOPSIS
					Converts objects into a DataTable.
			
				.DESCRIPTION
					Converts objects into a DataTable, which are used for DataBinding.
			
				.PARAMETER  InputObject
					The input to convert into a DataTable.
			
				.PARAMETER  Table
					The DataTable you wish to load the input into.
			
				.PARAMETER RetainColumns
					This switch tells the function to keep the DataTable's existing columns.
				
				.PARAMETER FilterWMIProperties
					This switch removes WMI properties that start with an underline.
			
				.EXAMPLE
					$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
			#>
		[OutputType([System.Data.DataTable])]
		param (
			[ValidateNotNull()]
			$InputObject,
			[ValidateNotNull()]
			[System.Data.DataTable]$Table,
			[switch]$RetainColumns,
			[switch]$FilterWMIProperties)
		
		if ($Table -eq $null)
		{
			$Table = New-Object System.Data.DataTable
		}
		
		if ($InputObject -is [System.Data.DataTable])
		{
			$Table = $InputObject
		}
		else
		{
			if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
			{
				#Clear out the Table Contents
				$Table.Clear()
				
				if ($InputObject -eq $null) { return } #Empty Data
				
				$object = $null
				#find the first non null value
				foreach ($item in $InputObject)
				{
					if ($item -ne $null)
					{
						$object = $item
						break
					}
				}
				
				if ($object -eq $null) { return } #All null then empty
				
				#Get all the properties in order to create the columns
				foreach ($prop in $object.PSObject.Get_Properties())
				{
					if (-not $FilterWMIProperties -or -not $prop.Name.StartsWith('__'))#filter out WMI properties
					{
						#Get the type from the Definition string
						$type = $null
						
						if ($prop.Value -ne $null)
						{
							try { $type = $prop.Value.GetType() }
							catch { }
						}
						
						if ($type -ne $null) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
						{
							[void]$table.Columns.Add($prop.Name, $type)
						}
						else #Type info not found
						{
							[void]$table.Columns.Add($prop.Name)
						}
					}
				}
				
				if ($object -is [System.Data.DataRow])
				{
					foreach ($item in $InputObject)
					{
						$Table.Rows.Add($item)
					}
					return @(, $Table)
				}
			}
			else
			{
				$Table.Rows.Clear()
			}
			
			foreach ($item in $InputObject)
			{
				$row = $table.NewRow()
				
				if ($item)
				{
					foreach ($prop in $item.PSObject.Get_Properties())
					{
						if ($table.Columns.Contains($prop.Name))
						{
							$row.Item($prop.Name) = $prop.Value
						}
					}
				}
				[void]$table.Rows.Add($row)
			}
		}
		
		return @(, $Table)
	}
	
	function Out-DataTable
	{
	<# 
	.SYNOPSIS 
	Creates a DataTable for an object 
	.DESCRIPTION 
	Creates a DataTable based on an objects properties. 
	.INPUTS 
	Object 
	    Any object can be piped to Out-DataTable 
	.OUTPUTS 
	   System.Data.DataTable 
	.EXAMPLE 
	$dt = Get-psdrive| Out-DataTable 
	This example creates a DataTable from the properties of Get-psdrive and assigns output to $dt variable 
	.NOTES 
	Adapted from script by Marc van Orsouw see link 
	Version History 
	v1.0  - Chad Miller - Initial Release 
	v1.1  - Chad Miller - Fixed Issue with Properties 
	v1.2  - Chad Miller - Added setting column datatype by property as suggested by emp0 
	v1.3  - Chad Miller - Corrected issue with setting datatype on empty properties 
	v1.4  - Chad Miller - Corrected issue with DBNull 
	v1.5  - Chad Miller - Updated example 
	v1.6  - Chad Miller - Added column datatype logic with default to string 
	v1.7 - Chad Miller - Fixed issue with IsArray 
	.LINK 
	http://thepowershellguy.com/blogs/posh/archive/2007/01/21/powershell-gui-scripblock-monitor-script.aspx 
	#>
		[CmdletBinding()]
		param ([Parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $true)] [PSObject[]]$InputObject)
		
		Begin
		{
			function Get-Type
			{
				param ($type)
				
				$types = @(
				'System.Boolean',
				'System.Byte[]',
				'System.Byte',
				'System.Char',
				'System.Datetime',
				'System.Decimal',
				'System.Double',
				'System.Guid',
				'System.Int16',
				'System.Int32',
				'System.Int64',
				'System.Single',
				'System.UInt16',
				'System.UInt32',
				'System.UInt64')
				
				if ($types -contains $type)
				{
					Write-Output "$type"
				}
				else
				{
					Write-Output 'System.String'
					
				}
			} #Get-Type
			
			$dt = new-object Data.datatable
			$First = $true
		}
		Process
		{
			foreach ($object in $InputObject)
			{
				$DR = $DT.NewRow()
				foreach ($property in $object.PsObject.get_properties())
				{
					if ($first)
					{
						$Col = new-object Data.DataColumn
						$Col.ColumnName = $property.Name.ToString()
						if ($property.value)
						{
							if ($property.value -isnot [System.DBNull])
							{
								$Col.DataType = [System.Type]::GetType("$(Get-Type $property.TypeNameOfValue)")
							}
						}
						$DT.Columns.Add($Col)
					}
					if ($property.Gettype().IsArray)
					{
						$DR.Item($property.Name) = $property.value | ConvertTo-XML -AS String -NoTypeInformation -Depth 1
					}
					else
					{
						$DR.Item($property.Name) = $property.value
					}
				}
				$DT.Rows.Add($DR)
				$First = $false
			}
		}
		
		End
		{
			Write-Output @(, ($dt))
		}
		
	} #Out-DataTable
	
	#endregion
	
	$datagridview1_ColumnHeaderMouseClick=[System.Windows.Forms.DataGridViewCellMouseEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellMouseEventArgs]
		if ($datagridview1.DataSource -is [System.Data.DataTable])
		{
			$column = $datagridview1.Columns[$_.ColumnIndex]
			$direction = [System.ComponentModel.ListSortDirection]::Ascending
			
			if ($column.HeaderCell.SortGlyphDirection -eq 'Descending')
			{
				$direction = [System.ComponentModel.ListSortDirection]::Descending
			}
			
			$datagridview1.Sort($datagridview1.Columns[$_.ColumnIndex], $direction)
		}
	}
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$form1.WindowState = $InitialFormWindowState
	}
	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$datagridview1.remove_ColumnHeaderMouseClick($datagridview1_ColumnHeaderMouseClick)
			$form1.remove_Load($form1_Load)
			$form1.remove_Load($Form_StateCorrection_Load)
			$form1.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$form1.SuspendLayout()
	#
	# form1
	#
	$form1.Controls.Add($datagridview1)
	$form1.ClientSize = '263, 173'
	$form1.Name = "form1"
	$form1.Text = "Form"
	$form1.add_Load($form1_Load)
	#
	# datagridview1
	#
	$datagridview1.ColumnHeadersHeightSizeMode = 'AutoSize'
	$datagridview1.Dock = 'Fill'
	$datagridview1.Location = '0, 0'
	$datagridview1.Name = "datagridview1"
	$datagridview1.Size = '263, 173'
	$datagridview1.TabIndex = 0
	$datagridview1.add_ColumnHeaderMouseClick($datagridview1_ColumnHeaderMouseClick)
	$form1.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $form1.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$form1.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$form1.add_FormClosed($Form_Cleanup_FormClosed)
	#Show the Form
	return $form1.ShowDialog()

} #End Function

#Call OnApplicationLoad to initialize
if((OnApplicationLoad) -eq $true)
{
	#Call the form
	Call-DataGridView_ColumnHeader_Sorting_psf | Out-Null
	#Perform cleanup
	OnApplicationExit
}
